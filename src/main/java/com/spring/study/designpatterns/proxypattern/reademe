代理模式：给对象创建一个代理来控制对象的访问，来实现对目标对象的增强或者
    分类：
        静态代理
        动态代理
            jdk：必须有接口
            cglib：可以没有接口
    结构:
        抽象主题：声明业务方法
        真实主题：实现抽象主题的业务方法
        代理类：提供与真实主题相同的接口，内部包含对真实主题的引用，可以访问、控制、扩展真实主题的功能
    优点：
        保护目标对象，扩展（增强）目标对象，将客户端与目标对象隔离，起到两者之间的解耦作用
    缺点：
        增加复杂度
    静态代理：
        代理类需要实现跟目标对象相同的接口，可以通过聚合或者组合的方式来创建目标对象
            聚合的方式是在代理类中声明一个目标对象但是不创建，需要在客户端创建目标对象并传给（setter或者构造函数）代理对象，这样的话就暴露了目标对象，不过对与目标对象实现相同接口的其他对象方便使用
            组合的方式是在代理类中直接new一个目标对象，这样就不会在客户端暴露目标对象，但是这样的方式只能代理一个对象，对与目标对象实现相同接口的其他对象无法代理
        优点：在不修改目标对象的前提下，实现对目标对象的扩展
        缺点：代理对象需要与目标对象实现同样的，一旦接口增加方法， 代理类和目标类都需要修改
    动态代理：
        JDK动态代理：底层采用反射来创建代理类，生成的代理类实现了目标类的接口
            代理工厂不需要实现目标接口的对象，目标对象还是需要实现接口
            执行流程：
                1、客户端调用代理类的目标方法
                2、代理类的目标方法调用InvocationHandler的invoke方法
                3、invoke通过反射执行目标对象的目标方法
        cglib动态代理：底层通过使用字节码处理框架ASM来转换字节码并生成新的类，继承目标类，所以代理的类不能是final
        对比：
            动态代理&静态代理：动态代理把接口中所有方法用一个方法处理，静态代理需要实现接口针对每个方法编写代理方法；如果接口增加了方法，实现类和代理类都要修改
            jdk动态代理&cglib动态代理：jdk1.6之前，cglib效率比反射要高，在jdk1.6、1.7、1.8对动态代理优化后，在调用次数较少的情况下jdk代理效率高于cglib，大量调用的情况下jdk动态代理效率低于cglib，在1.8之后jdk动态代理效率高于cglib
            如果有接口使用jdk动态代理，没有接口使用cglib

